// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: base/types/gfspserver/authenticator.proto

package gfspserver

import (
	context "context"
	fmt "fmt"
	gfsperrors "github.com/bnb-chain/greenfield-storage-provider/base/types/gfsperrors"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type GfSpAuthenticationRequest struct {
	AuthType    int32  `protobuf:"varint,1,opt,name=auth_type,json=authType,proto3" json:"auth_type,omitempty"`
	UserAccount string `protobuf:"bytes,2,opt,name=user_account,json=userAccount,proto3" json:"user_account,omitempty"`
	BucketName  string `protobuf:"bytes,3,opt,name=bucket_name,json=bucketName,proto3" json:"bucket_name,omitempty"`
	ObjectName  string `protobuf:"bytes,4,opt,name=object_name,json=objectName,proto3" json:"object_name,omitempty"`
}

func (m *GfSpAuthenticationRequest) Reset()         { *m = GfSpAuthenticationRequest{} }
func (m *GfSpAuthenticationRequest) String() string { return proto.CompactTextString(m) }
func (*GfSpAuthenticationRequest) ProtoMessage()    {}
func (*GfSpAuthenticationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ebf94e0d260942, []int{0}
}
func (m *GfSpAuthenticationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpAuthenticationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpAuthenticationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpAuthenticationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpAuthenticationRequest.Merge(m, src)
}
func (m *GfSpAuthenticationRequest) XXX_Size() int {
	return m.Size()
}
func (m *GfSpAuthenticationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpAuthenticationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpAuthenticationRequest proto.InternalMessageInfo

func (m *GfSpAuthenticationRequest) GetAuthType() int32 {
	if m != nil {
		return m.AuthType
	}
	return 0
}

func (m *GfSpAuthenticationRequest) GetUserAccount() string {
	if m != nil {
		return m.UserAccount
	}
	return ""
}

func (m *GfSpAuthenticationRequest) GetBucketName() string {
	if m != nil {
		return m.BucketName
	}
	return ""
}

func (m *GfSpAuthenticationRequest) GetObjectName() string {
	if m != nil {
		return m.ObjectName
	}
	return ""
}

type GfSpAuthenticationResponse struct {
	Err     *gfsperrors.GfSpError `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	Allowed bool                  `protobuf:"varint,2,opt,name=allowed,proto3" json:"allowed,omitempty"`
}

func (m *GfSpAuthenticationResponse) Reset()         { *m = GfSpAuthenticationResponse{} }
func (m *GfSpAuthenticationResponse) String() string { return proto.CompactTextString(m) }
func (*GfSpAuthenticationResponse) ProtoMessage()    {}
func (*GfSpAuthenticationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ebf94e0d260942, []int{1}
}
func (m *GfSpAuthenticationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpAuthenticationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpAuthenticationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpAuthenticationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpAuthenticationResponse.Merge(m, src)
}
func (m *GfSpAuthenticationResponse) XXX_Size() int {
	return m.Size()
}
func (m *GfSpAuthenticationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpAuthenticationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpAuthenticationResponse proto.InternalMessageInfo

func (m *GfSpAuthenticationResponse) GetErr() *gfsperrors.GfSpError {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GfSpAuthenticationResponse) GetAllowed() bool {
	if m != nil {
		return m.Allowed
	}
	return false
}

// GetAuthNonceRequest is request type for the GetAuthNonce RPC method.
type GetAuthNonceRequest struct {
	// account_id is the account address of user
	AccountId string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
	// domain is the DApp domain for this nonce
	Domain string `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
}

func (m *GetAuthNonceRequest) Reset()         { *m = GetAuthNonceRequest{} }
func (m *GetAuthNonceRequest) String() string { return proto.CompactTextString(m) }
func (*GetAuthNonceRequest) ProtoMessage()    {}
func (*GetAuthNonceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ebf94e0d260942, []int{2}
}
func (m *GetAuthNonceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAuthNonceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAuthNonceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAuthNonceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAuthNonceRequest.Merge(m, src)
}
func (m *GetAuthNonceRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAuthNonceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAuthNonceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAuthNonceRequest proto.InternalMessageInfo

func (m *GetAuthNonceRequest) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *GetAuthNonceRequest) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

// GetAuthNonceResponse is response type for the GetAuthNonce RPC method.
type GetAuthNonceResponse struct {
	Err *gfsperrors.GfSpError `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	// current_nonce defines the current nonce value, which the current_public_key is tied to
	CurrentNonce int32 `protobuf:"varint,2,opt,name=current_nonce,json=currentNonce,proto3" json:"current_nonce,omitempty"`
	// next_nonce defines the next nonce value , for which the DApp or client can update their auth public key
	NextNonce int32 `protobuf:"varint,3,opt,name=next_nonce,json=nextNonce,proto3" json:"next_nonce,omitempty"`
	// current_public_key defines the current user EDDSA public key
	CurrentPublicKey string `protobuf:"bytes,4,opt,name=current_public_key,json=currentPublicKey,proto3" json:"current_public_key,omitempty"`
	// expiry_date is the expiry timestamp of the current public key
	ExpiryDate int64 `protobuf:"varint,5,opt,name=expiry_date,json=expiryDate,proto3" json:"expiry_date,omitempty"`
}

func (m *GetAuthNonceResponse) Reset()         { *m = GetAuthNonceResponse{} }
func (m *GetAuthNonceResponse) String() string { return proto.CompactTextString(m) }
func (*GetAuthNonceResponse) ProtoMessage()    {}
func (*GetAuthNonceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ebf94e0d260942, []int{3}
}
func (m *GetAuthNonceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAuthNonceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAuthNonceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAuthNonceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAuthNonceResponse.Merge(m, src)
}
func (m *GetAuthNonceResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetAuthNonceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAuthNonceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetAuthNonceResponse proto.InternalMessageInfo

func (m *GetAuthNonceResponse) GetErr() *gfsperrors.GfSpError {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetAuthNonceResponse) GetCurrentNonce() int32 {
	if m != nil {
		return m.CurrentNonce
	}
	return 0
}

func (m *GetAuthNonceResponse) GetNextNonce() int32 {
	if m != nil {
		return m.NextNonce
	}
	return 0
}

func (m *GetAuthNonceResponse) GetCurrentPublicKey() string {
	if m != nil {
		return m.CurrentPublicKey
	}
	return ""
}

func (m *GetAuthNonceResponse) GetExpiryDate() int64 {
	if m != nil {
		return m.ExpiryDate
	}
	return 0
}

// UpdateUserPublicKeyRequest is request type for the UpdateUserPublicKey RPC method.
type UpdateUserPublicKeyRequest struct {
	// account_id is the account address of user
	AccountId string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
	// domain is the DApp domain for which the public key is updated
	Domain string `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
	// current_nonce is the current_nonce value for which the existing public key is matching
	CurrentNonce int32 `protobuf:"varint,3,opt,name=current_nonce,json=currentNonce,proto3" json:"current_nonce,omitempty"`
	// nonce is the nonce value for which the public key is updated
	Nonce int32 `protobuf:"varint,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// user_public_key is the public key value to update in SP database
	UserPublicKey string `protobuf:"bytes,5,opt,name=user_public_key,json=userPublicKey,proto3" json:"user_public_key,omitempty"`
	// expiry_date is the expiry timestamp of the public key
	ExpiryDate int64 `protobuf:"varint,6,opt,name=expiry_date,json=expiryDate,proto3" json:"expiry_date,omitempty"`
}

func (m *UpdateUserPublicKeyRequest) Reset()         { *m = UpdateUserPublicKeyRequest{} }
func (m *UpdateUserPublicKeyRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateUserPublicKeyRequest) ProtoMessage()    {}
func (*UpdateUserPublicKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ebf94e0d260942, []int{4}
}
func (m *UpdateUserPublicKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateUserPublicKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateUserPublicKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateUserPublicKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateUserPublicKeyRequest.Merge(m, src)
}
func (m *UpdateUserPublicKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateUserPublicKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateUserPublicKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateUserPublicKeyRequest proto.InternalMessageInfo

func (m *UpdateUserPublicKeyRequest) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *UpdateUserPublicKeyRequest) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *UpdateUserPublicKeyRequest) GetCurrentNonce() int32 {
	if m != nil {
		return m.CurrentNonce
	}
	return 0
}

func (m *UpdateUserPublicKeyRequest) GetNonce() int32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *UpdateUserPublicKeyRequest) GetUserPublicKey() string {
	if m != nil {
		return m.UserPublicKey
	}
	return ""
}

func (m *UpdateUserPublicKeyRequest) GetExpiryDate() int64 {
	if m != nil {
		return m.ExpiryDate
	}
	return 0
}

// UpdateUserPublicKeyResponse is response type for the UpdateUserPublicKey RPC method.
type UpdateUserPublicKeyResponse struct {
	Err *gfsperrors.GfSpError `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	// result defines the result of if the user public key is updated
	Result bool `protobuf:"varint,2,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *UpdateUserPublicKeyResponse) Reset()         { *m = UpdateUserPublicKeyResponse{} }
func (m *UpdateUserPublicKeyResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateUserPublicKeyResponse) ProtoMessage()    {}
func (*UpdateUserPublicKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ebf94e0d260942, []int{5}
}
func (m *UpdateUserPublicKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateUserPublicKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateUserPublicKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateUserPublicKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateUserPublicKeyResponse.Merge(m, src)
}
func (m *UpdateUserPublicKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateUserPublicKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateUserPublicKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateUserPublicKeyResponse proto.InternalMessageInfo

func (m *UpdateUserPublicKeyResponse) GetErr() *gfsperrors.GfSpError {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *UpdateUserPublicKeyResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

// Deprecated: This method will be deleted in future versions, once most SP and clients migrates to GNFD1 Auth.
// VerifyOffChainSignatureRequest is request type for the VerifyOffChainSignature RPC method.
type VerifyOffChainSignatureRequest struct {
	// account_id is the account address of user
	AccountId string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
	// domain is the DApp domain for which the public key is updated
	Domain string `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
	// off_chain_sig is the off chain signature signed by user's eddsa seed private key
	OffChainSig string `protobuf:"bytes,3,opt,name=off_chain_sig,json=offChainSig,proto3" json:"off_chain_sig,omitempty"`
	// real_msg_to_sign is the msg that the off_chain_sig is signed for
	RealMsgToSign string `protobuf:"bytes,4,opt,name=real_msg_to_sign,json=realMsgToSign,proto3" json:"real_msg_to_sign,omitempty"`
}

func (m *VerifyOffChainSignatureRequest) Reset()         { *m = VerifyOffChainSignatureRequest{} }
func (m *VerifyOffChainSignatureRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyOffChainSignatureRequest) ProtoMessage()    {}
func (*VerifyOffChainSignatureRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ebf94e0d260942, []int{6}
}
func (m *VerifyOffChainSignatureRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyOffChainSignatureRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyOffChainSignatureRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyOffChainSignatureRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyOffChainSignatureRequest.Merge(m, src)
}
func (m *VerifyOffChainSignatureRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyOffChainSignatureRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyOffChainSignatureRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyOffChainSignatureRequest proto.InternalMessageInfo

func (m *VerifyOffChainSignatureRequest) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *VerifyOffChainSignatureRequest) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *VerifyOffChainSignatureRequest) GetOffChainSig() string {
	if m != nil {
		return m.OffChainSig
	}
	return ""
}

func (m *VerifyOffChainSignatureRequest) GetRealMsgToSign() string {
	if m != nil {
		return m.RealMsgToSign
	}
	return ""
}

// VerifyGNFD1EddsaSignatureRequest is request type for the VerifyGNFD1EddsaSignature RPC method.
type VerifyGNFD1EddsaSignatureRequest struct {
	// account_id is the account address of user
	AccountId string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
	// domain is the DApp domain for which the public key is updated
	Domain string `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
	// off_chain_sig is the off chain signature signed by user's eddsa seed private key
	OffChainSig string `protobuf:"bytes,3,opt,name=off_chain_sig,json=offChainSig,proto3" json:"off_chain_sig,omitempty"`
	// real_msg_to_sign is the msg that the off_chain_sig is signed for
	RealMsgToSign []byte `protobuf:"bytes,4,opt,name=real_msg_to_sign,json=realMsgToSign,proto3" json:"real_msg_to_sign,omitempty"`
}

func (m *VerifyGNFD1EddsaSignatureRequest) Reset()         { *m = VerifyGNFD1EddsaSignatureRequest{} }
func (m *VerifyGNFD1EddsaSignatureRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyGNFD1EddsaSignatureRequest) ProtoMessage()    {}
func (*VerifyGNFD1EddsaSignatureRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ebf94e0d260942, []int{7}
}
func (m *VerifyGNFD1EddsaSignatureRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyGNFD1EddsaSignatureRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyGNFD1EddsaSignatureRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyGNFD1EddsaSignatureRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyGNFD1EddsaSignatureRequest.Merge(m, src)
}
func (m *VerifyGNFD1EddsaSignatureRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyGNFD1EddsaSignatureRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyGNFD1EddsaSignatureRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyGNFD1EddsaSignatureRequest proto.InternalMessageInfo

func (m *VerifyGNFD1EddsaSignatureRequest) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *VerifyGNFD1EddsaSignatureRequest) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *VerifyGNFD1EddsaSignatureRequest) GetOffChainSig() string {
	if m != nil {
		return m.OffChainSig
	}
	return ""
}

func (m *VerifyGNFD1EddsaSignatureRequest) GetRealMsgToSign() []byte {
	if m != nil {
		return m.RealMsgToSign
	}
	return nil
}

// VerifyOffChainSignatureResponse is response type for the VerifyOffChainSignature RPC method.
type VerifyOffChainSignatureResponse struct {
	Err *gfsperrors.GfSpError `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	// result defines the result of if the OffChainSignature is verified
	Result bool `protobuf:"varint,2,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *VerifyOffChainSignatureResponse) Reset()         { *m = VerifyOffChainSignatureResponse{} }
func (m *VerifyOffChainSignatureResponse) String() string { return proto.CompactTextString(m) }
func (*VerifyOffChainSignatureResponse) ProtoMessage()    {}
func (*VerifyOffChainSignatureResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_30ebf94e0d260942, []int{8}
}
func (m *VerifyOffChainSignatureResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyOffChainSignatureResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyOffChainSignatureResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyOffChainSignatureResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyOffChainSignatureResponse.Merge(m, src)
}
func (m *VerifyOffChainSignatureResponse) XXX_Size() int {
	return m.Size()
}
func (m *VerifyOffChainSignatureResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyOffChainSignatureResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyOffChainSignatureResponse proto.InternalMessageInfo

func (m *VerifyOffChainSignatureResponse) GetErr() *gfsperrors.GfSpError {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *VerifyOffChainSignatureResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func init() {
	proto.RegisterType((*GfSpAuthenticationRequest)(nil), "base.types.gfspserver.GfSpAuthenticationRequest")
	proto.RegisterType((*GfSpAuthenticationResponse)(nil), "base.types.gfspserver.GfSpAuthenticationResponse")
	proto.RegisterType((*GetAuthNonceRequest)(nil), "base.types.gfspserver.GetAuthNonceRequest")
	proto.RegisterType((*GetAuthNonceResponse)(nil), "base.types.gfspserver.GetAuthNonceResponse")
	proto.RegisterType((*UpdateUserPublicKeyRequest)(nil), "base.types.gfspserver.UpdateUserPublicKeyRequest")
	proto.RegisterType((*UpdateUserPublicKeyResponse)(nil), "base.types.gfspserver.UpdateUserPublicKeyResponse")
	proto.RegisterType((*VerifyOffChainSignatureRequest)(nil), "base.types.gfspserver.VerifyOffChainSignatureRequest")
	proto.RegisterType((*VerifyGNFD1EddsaSignatureRequest)(nil), "base.types.gfspserver.VerifyGNFD1EddsaSignatureRequest")
	proto.RegisterType((*VerifyOffChainSignatureResponse)(nil), "base.types.gfspserver.VerifyOffChainSignatureResponse")
}

func init() {
	proto.RegisterFile("base/types/gfspserver/authenticator.proto", fileDescriptor_30ebf94e0d260942)
}

var fileDescriptor_30ebf94e0d260942 = []byte{
	// 758 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0xcd, 0x6e, 0x23, 0x45,
	0x10, 0xf6, 0xe0, 0xd8, 0xc4, 0x65, 0x5b, 0x44, 0x9d, 0x10, 0x1c, 0x47, 0x38, 0xce, 0x20, 0x41,
	0xf8, 0xc9, 0x98, 0x18, 0x01, 0xe7, 0x40, 0x7e, 0x84, 0x80, 0x80, 0x26, 0x09, 0x07, 0x2e, 0xc3,
	0xfc, 0xd4, 0x4c, 0x3a, 0xb1, 0xa7, 0x87, 0xee, 0x9e, 0x10, 0x5f, 0x90, 0xb8, 0x72, 0x40, 0xbc,
	0xc0, 0xde, 0x56, 0xab, 0x7d, 0x94, 0x3d, 0xe6, 0xb6, 0x7b, 0x59, 0x69, 0x95, 0xbc, 0xc8, 0xaa,
	0x67, 0xc6, 0x4e, 0xe2, 0x78, 0xa2, 0xcd, 0x7a, 0x0f, 0x7b, 0xb2, 0xbb, 0xea, 0xab, 0xaf, 0xbe,
	0xaa, 0xee, 0x2a, 0x0d, 0x7c, 0xea, 0xd8, 0x02, 0x3b, 0x72, 0x10, 0xa1, 0xe8, 0x04, 0xbe, 0x88,
	0x04, 0xf2, 0x53, 0xe4, 0x1d, 0x3b, 0x96, 0x47, 0x18, 0x4a, 0xea, 0xda, 0x92, 0x71, 0x23, 0xe2,
	0x4c, 0x32, 0xf2, 0xbe, 0x82, 0x1a, 0x09, 0xd4, 0xb8, 0x82, 0x36, 0x57, 0xc7, 0x18, 0x90, 0x73,
	0xc6, 0x45, 0x27, 0xf9, 0x49, 0x23, 0xf5, 0x07, 0x1a, 0x2c, 0xed, 0xfa, 0xfb, 0xd1, 0xe6, 0x15,
	0x2b, 0x65, 0xa1, 0x89, 0x7f, 0xc6, 0x28, 0x24, 0x59, 0x86, 0x8a, 0x4a, 0x67, 0x29, 0x8a, 0x86,
	0xd6, 0xd6, 0xd6, 0x4a, 0xe6, 0xac, 0x32, 0x1c, 0x0c, 0x22, 0x24, 0xab, 0x50, 0x8b, 0x05, 0x72,
	0xcb, 0x76, 0x5d, 0x16, 0x87, 0xb2, 0xf1, 0x4e, 0x5b, 0x5b, 0xab, 0x98, 0x55, 0x65, 0xdb, 0x4c,
	0x4d, 0x64, 0x05, 0xaa, 0x4e, 0xec, 0x9e, 0xa0, 0xb4, 0x42, 0xbb, 0x8f, 0x8d, 0x62, 0x82, 0x80,
	0xd4, 0xb4, 0x67, 0xf7, 0x51, 0x01, 0x98, 0x73, 0x8c, 0x6e, 0x06, 0x98, 0x49, 0x01, 0xa9, 0x49,
	0x01, 0xf4, 0x63, 0x68, 0x4e, 0x92, 0x27, 0x22, 0x16, 0x0a, 0x24, 0x5d, 0x28, 0x22, 0xe7, 0x89,
	0xb2, 0x6a, 0xb7, 0x6d, 0x8c, 0x75, 0x21, 0x2d, 0xd7, 0x50, 0xf1, 0xdb, 0xea, 0xaf, 0xa9, 0xc0,
	0xa4, 0x01, 0xef, 0xda, 0xbd, 0x1e, 0xfb, 0x0b, 0xbd, 0x44, 0xf1, 0xac, 0x39, 0x3c, 0xea, 0x3f,
	0xc1, 0xfc, 0x2e, 0x4a, 0x95, 0x6a, 0x8f, 0x85, 0x2e, 0x0e, 0x9b, 0xf0, 0x21, 0x40, 0x56, 0xa2,
	0x45, 0xbd, 0x24, 0x57, 0xc5, 0xac, 0x64, 0x96, 0x1f, 0x3c, 0xb2, 0x08, 0x65, 0x8f, 0xf5, 0x6d,
	0x1a, 0x66, 0x0d, 0xc8, 0x4e, 0xfa, 0x73, 0x0d, 0x16, 0x6e, 0xd2, 0x4d, 0x21, 0xfa, 0x23, 0xa8,
	0xbb, 0x31, 0xe7, 0x18, 0x4a, 0x2b, 0x54, 0x64, 0x49, 0xae, 0x92, 0x59, 0xcb, 0x8c, 0x49, 0x02,
	0x25, 0x34, 0xc4, 0xb3, 0x21, 0xa2, 0x98, 0x20, 0x2a, 0xca, 0x92, 0xba, 0xbf, 0x00, 0x32, 0xe4,
	0x88, 0x62, 0xa7, 0x47, 0x5d, 0xeb, 0x04, 0x07, 0x59, 0xcb, 0xe7, 0x32, 0xcf, 0xaf, 0x89, 0xe3,
	0x47, 0x1c, 0xa8, 0x9b, 0xc1, 0xb3, 0x88, 0xf2, 0x81, 0xe5, 0xd9, 0x12, 0x1b, 0xa5, 0xb6, 0xb6,
	0x56, 0x34, 0x21, 0x35, 0x6d, 0xd9, 0x12, 0xf5, 0xa7, 0x1a, 0x34, 0x0f, 0x23, 0xe5, 0x3c, 0x14,
	0xc8, 0x47, 0x81, 0xd3, 0x75, 0xed, 0x76, 0xa1, 0xc5, 0x09, 0x85, 0x2e, 0x40, 0x29, 0x75, 0xce,
	0x24, 0xce, 0xf4, 0x40, 0x3e, 0x86, 0xf7, 0x92, 0xf7, 0x78, 0xad, 0xb8, 0x52, 0xc2, 0x5d, 0x8f,
	0xaf, 0x0b, 0x1c, 0xaf, 0xac, 0x7c, 0xab, 0x32, 0x0a, 0xcb, 0x13, 0x0b, 0x9b, 0xe2, 0xfe, 0x16,
	0xa1, 0xcc, 0x51, 0xc4, 0x3d, 0x99, 0xbd, 0xb9, 0xec, 0xa4, 0x3f, 0xd4, 0xa0, 0xf5, 0x1b, 0x72,
	0xea, 0x0f, 0x7e, 0xf1, 0xfd, 0xef, 0x8f, 0x6c, 0x1a, 0xee, 0xd3, 0x20, 0xb4, 0x65, 0xcc, 0xa7,
	0x7c, 0x7e, 0x44, 0x87, 0x3a, 0xf3, 0x7d, 0xcb, 0x55, 0x9c, 0x96, 0xa0, 0x41, 0x36, 0x7c, 0x55,
	0x76, 0x95, 0x87, 0x7c, 0x02, 0x73, 0x1c, 0xed, 0x9e, 0xd5, 0x17, 0x81, 0x25, 0x99, 0x42, 0x85,
	0xd9, 0x7b, 0xa8, 0x2b, 0xfb, 0xcf, 0x22, 0x38, 0x60, 0x4a, 0x8f, 0xfe, 0x48, 0x83, 0x76, 0x2a,
	0x73, 0x77, 0x6f, 0x67, 0x6b, 0x63, 0xdb, 0xf3, 0x84, 0xfd, 0x36, 0x08, 0xad, 0x8d, 0x0b, 0xed,
	0xc3, 0x4a, 0x6e, 0x3b, 0xdf, 0xfc, 0xf5, 0x75, 0x1f, 0x97, 0x26, 0x6d, 0xcf, 0x7d, 0xe4, 0xa7,
	0xd4, 0x45, 0xf2, 0x8f, 0x06, 0x0d, 0xe5, 0x4d, 0x15, 0xdd, 0xc4, 0x90, 0x2f, 0x8d, 0x89, 0x3b,
	0xdb, 0xc8, 0x5d, 0xc6, 0xcd, 0x8d, 0x7b, 0x44, 0xa4, 0xb5, 0xea, 0x05, 0x42, 0xa1, 0x76, 0x7d,
	0x09, 0x91, 0xcf, 0xf2, 0x48, 0x6e, 0x2f, 0xbe, 0xe6, 0xe7, 0xaf, 0x84, 0x1d, 0xa5, 0xfa, 0x1b,
	0xe6, 0x27, 0x8c, 0x0d, 0xc9, 0x93, 0x9d, 0xbf, 0x3b, 0x9a, 0xdd, 0xfb, 0x84, 0x8c, 0xf2, 0xff,
	0xab, 0xc1, 0x07, 0x39, 0x97, 0x4f, 0xbe, 0xce, 0x61, 0xbc, 0x7b, 0xf6, 0x9a, 0xdf, 0xdc, 0x37,
	0x6c, 0x24, 0xe6, 0x3f, 0x0d, 0x96, 0x72, 0x27, 0x86, 0x7c, 0x7b, 0x27, 0x6f, 0xfe, 0x8c, 0xbd,
	0xbe, 0xa0, 0xef, 0xfe, 0x78, 0x72, 0xd1, 0xd2, 0xce, 0x2f, 0x5a, 0xda, 0x8b, 0x8b, 0x96, 0xf6,
	0xff, 0x65, 0xab, 0x70, 0x7e, 0xd9, 0x2a, 0x3c, 0xbb, 0x6c, 0x15, 0x7e, 0xdf, 0x09, 0xa8, 0x3c,
	0x8a, 0x1d, 0xc3, 0x65, 0xfd, 0x8e, 0x13, 0x3a, 0xeb, 0xc9, 0x24, 0x76, 0x02, 0x8e, 0x18, 0xfa,
	0x14, 0x7b, 0xde, 0xba, 0x90, 0x8c, 0xdb, 0x01, 0xae, 0x47, 0x9c, 0x9d, 0x52, 0x0f, 0x79, 0x67,
	0xe2, 0x87, 0x89, 0x53, 0x4e, 0xbe, 0x28, 0xbe, 0x7a, 0x19, 0x00, 0x00, 0xff, 0xff, 0x25, 0x5f,
	0x55, 0x09, 0xb8, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GfSpAuthenticationServiceClient is the client API for GfSpAuthenticationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GfSpAuthenticationServiceClient interface {
	GfSpVerifyAuthentication(ctx context.Context, in *GfSpAuthenticationRequest, opts ...grpc.CallOption) (*GfSpAuthenticationResponse, error)
	// GetAuthNonce get the auth nonce for which the Dapp or client can generate EDDSA key pairs.
	GetAuthNonce(ctx context.Context, in *GetAuthNonceRequest, opts ...grpc.CallOption) (*GetAuthNonceResponse, error)
	// UpdateUserPublicKey updates the user public key once the Dapp or client generates the EDDSA key pairs.
	UpdateUserPublicKey(ctx context.Context, in *UpdateUserPublicKeyRequest, opts ...grpc.CallOption) (*UpdateUserPublicKeyResponse, error)
	// Deprecated: This method will be deleted in future versions, once most SP and clients migrates to GNFD1 Auth.
	// VerifyOffChainSignature verifies the signature signed by user's EDDSA private key.
	VerifyOffChainSignature(ctx context.Context, in *VerifyOffChainSignatureRequest, opts ...grpc.CallOption) (*VerifyOffChainSignatureResponse, error)
	// VerifyGNFD1EddsaSignature verifies the signature signed by user's EDDSA private key.
	VerifyGNFD1EddsaSignature(ctx context.Context, in *VerifyGNFD1EddsaSignatureRequest, opts ...grpc.CallOption) (*VerifyOffChainSignatureResponse, error)
}

type gfSpAuthenticationServiceClient struct {
	cc grpc1.ClientConn
}

func NewGfSpAuthenticationServiceClient(cc grpc1.ClientConn) GfSpAuthenticationServiceClient {
	return &gfSpAuthenticationServiceClient{cc}
}

func (c *gfSpAuthenticationServiceClient) GfSpVerifyAuthentication(ctx context.Context, in *GfSpAuthenticationRequest, opts ...grpc.CallOption) (*GfSpAuthenticationResponse, error) {
	out := new(GfSpAuthenticationResponse)
	err := c.cc.Invoke(ctx, "/base.types.gfspserver.GfSpAuthenticationService/GfSpVerifyAuthentication", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gfSpAuthenticationServiceClient) GetAuthNonce(ctx context.Context, in *GetAuthNonceRequest, opts ...grpc.CallOption) (*GetAuthNonceResponse, error) {
	out := new(GetAuthNonceResponse)
	err := c.cc.Invoke(ctx, "/base.types.gfspserver.GfSpAuthenticationService/GetAuthNonce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gfSpAuthenticationServiceClient) UpdateUserPublicKey(ctx context.Context, in *UpdateUserPublicKeyRequest, opts ...grpc.CallOption) (*UpdateUserPublicKeyResponse, error) {
	out := new(UpdateUserPublicKeyResponse)
	err := c.cc.Invoke(ctx, "/base.types.gfspserver.GfSpAuthenticationService/UpdateUserPublicKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gfSpAuthenticationServiceClient) VerifyOffChainSignature(ctx context.Context, in *VerifyOffChainSignatureRequest, opts ...grpc.CallOption) (*VerifyOffChainSignatureResponse, error) {
	out := new(VerifyOffChainSignatureResponse)
	err := c.cc.Invoke(ctx, "/base.types.gfspserver.GfSpAuthenticationService/VerifyOffChainSignature", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gfSpAuthenticationServiceClient) VerifyGNFD1EddsaSignature(ctx context.Context, in *VerifyGNFD1EddsaSignatureRequest, opts ...grpc.CallOption) (*VerifyOffChainSignatureResponse, error) {
	out := new(VerifyOffChainSignatureResponse)
	err := c.cc.Invoke(ctx, "/base.types.gfspserver.GfSpAuthenticationService/VerifyGNFD1EddsaSignature", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GfSpAuthenticationServiceServer is the server API for GfSpAuthenticationService service.
type GfSpAuthenticationServiceServer interface {
	GfSpVerifyAuthentication(context.Context, *GfSpAuthenticationRequest) (*GfSpAuthenticationResponse, error)
	// GetAuthNonce get the auth nonce for which the Dapp or client can generate EDDSA key pairs.
	GetAuthNonce(context.Context, *GetAuthNonceRequest) (*GetAuthNonceResponse, error)
	// UpdateUserPublicKey updates the user public key once the Dapp or client generates the EDDSA key pairs.
	UpdateUserPublicKey(context.Context, *UpdateUserPublicKeyRequest) (*UpdateUserPublicKeyResponse, error)
	// Deprecated: This method will be deleted in future versions, once most SP and clients migrates to GNFD1 Auth.
	// VerifyOffChainSignature verifies the signature signed by user's EDDSA private key.
	VerifyOffChainSignature(context.Context, *VerifyOffChainSignatureRequest) (*VerifyOffChainSignatureResponse, error)
	// VerifyGNFD1EddsaSignature verifies the signature signed by user's EDDSA private key.
	VerifyGNFD1EddsaSignature(context.Context, *VerifyGNFD1EddsaSignatureRequest) (*VerifyOffChainSignatureResponse, error)
}

// UnimplementedGfSpAuthenticationServiceServer can be embedded to have forward compatible implementations.
type UnimplementedGfSpAuthenticationServiceServer struct {
}

func (*UnimplementedGfSpAuthenticationServiceServer) GfSpVerifyAuthentication(ctx context.Context, req *GfSpAuthenticationRequest) (*GfSpAuthenticationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GfSpVerifyAuthentication not implemented")
}
func (*UnimplementedGfSpAuthenticationServiceServer) GetAuthNonce(ctx context.Context, req *GetAuthNonceRequest) (*GetAuthNonceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuthNonce not implemented")
}
func (*UnimplementedGfSpAuthenticationServiceServer) UpdateUserPublicKey(ctx context.Context, req *UpdateUserPublicKeyRequest) (*UpdateUserPublicKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserPublicKey not implemented")
}
func (*UnimplementedGfSpAuthenticationServiceServer) VerifyOffChainSignature(ctx context.Context, req *VerifyOffChainSignatureRequest) (*VerifyOffChainSignatureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyOffChainSignature not implemented")
}
func (*UnimplementedGfSpAuthenticationServiceServer) VerifyGNFD1EddsaSignature(ctx context.Context, req *VerifyGNFD1EddsaSignatureRequest) (*VerifyOffChainSignatureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyGNFD1EddsaSignature not implemented")
}

func RegisterGfSpAuthenticationServiceServer(s grpc1.Server, srv GfSpAuthenticationServiceServer) {
	s.RegisterService(&_GfSpAuthenticationService_serviceDesc, srv)
}

func _GfSpAuthenticationService_GfSpVerifyAuthentication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GfSpAuthenticationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GfSpAuthenticationServiceServer).GfSpVerifyAuthentication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/base.types.gfspserver.GfSpAuthenticationService/GfSpVerifyAuthentication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GfSpAuthenticationServiceServer).GfSpVerifyAuthentication(ctx, req.(*GfSpAuthenticationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GfSpAuthenticationService_GetAuthNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAuthNonceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GfSpAuthenticationServiceServer).GetAuthNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/base.types.gfspserver.GfSpAuthenticationService/GetAuthNonce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GfSpAuthenticationServiceServer).GetAuthNonce(ctx, req.(*GetAuthNonceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GfSpAuthenticationService_UpdateUserPublicKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserPublicKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GfSpAuthenticationServiceServer).UpdateUserPublicKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/base.types.gfspserver.GfSpAuthenticationService/UpdateUserPublicKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GfSpAuthenticationServiceServer).UpdateUserPublicKey(ctx, req.(*UpdateUserPublicKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GfSpAuthenticationService_VerifyOffChainSignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyOffChainSignatureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GfSpAuthenticationServiceServer).VerifyOffChainSignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/base.types.gfspserver.GfSpAuthenticationService/VerifyOffChainSignature",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GfSpAuthenticationServiceServer).VerifyOffChainSignature(ctx, req.(*VerifyOffChainSignatureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GfSpAuthenticationService_VerifyGNFD1EddsaSignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyGNFD1EddsaSignatureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GfSpAuthenticationServiceServer).VerifyGNFD1EddsaSignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/base.types.gfspserver.GfSpAuthenticationService/VerifyGNFD1EddsaSignature",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GfSpAuthenticationServiceServer).VerifyGNFD1EddsaSignature(ctx, req.(*VerifyGNFD1EddsaSignatureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _GfSpAuthenticationService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "base.types.gfspserver.GfSpAuthenticationService",
	HandlerType: (*GfSpAuthenticationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GfSpVerifyAuthentication",
			Handler:    _GfSpAuthenticationService_GfSpVerifyAuthentication_Handler,
		},
		{
			MethodName: "GetAuthNonce",
			Handler:    _GfSpAuthenticationService_GetAuthNonce_Handler,
		},
		{
			MethodName: "UpdateUserPublicKey",
			Handler:    _GfSpAuthenticationService_UpdateUserPublicKey_Handler,
		},
		{
			MethodName: "VerifyOffChainSignature",
			Handler:    _GfSpAuthenticationService_VerifyOffChainSignature_Handler,
		},
		{
			MethodName: "VerifyGNFD1EddsaSignature",
			Handler:    _GfSpAuthenticationService_VerifyGNFD1EddsaSignature_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "base/types/gfspserver/authenticator.proto",
}

func (m *GfSpAuthenticationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpAuthenticationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpAuthenticationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ObjectName) > 0 {
		i -= len(m.ObjectName)
		copy(dAtA[i:], m.ObjectName)
		i = encodeVarintAuthenticator(dAtA, i, uint64(len(m.ObjectName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BucketName) > 0 {
		i -= len(m.BucketName)
		copy(dAtA[i:], m.BucketName)
		i = encodeVarintAuthenticator(dAtA, i, uint64(len(m.BucketName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UserAccount) > 0 {
		i -= len(m.UserAccount)
		copy(dAtA[i:], m.UserAccount)
		i = encodeVarintAuthenticator(dAtA, i, uint64(len(m.UserAccount)))
		i--
		dAtA[i] = 0x12
	}
	if m.AuthType != 0 {
		i = encodeVarintAuthenticator(dAtA, i, uint64(m.AuthType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GfSpAuthenticationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpAuthenticationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpAuthenticationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Allowed {
		i--
		if m.Allowed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthenticator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAuthNonceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAuthNonceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAuthNonceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintAuthenticator(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountId) > 0 {
		i -= len(m.AccountId)
		copy(dAtA[i:], m.AccountId)
		i = encodeVarintAuthenticator(dAtA, i, uint64(len(m.AccountId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAuthNonceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAuthNonceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAuthNonceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiryDate != 0 {
		i = encodeVarintAuthenticator(dAtA, i, uint64(m.ExpiryDate))
		i--
		dAtA[i] = 0x28
	}
	if len(m.CurrentPublicKey) > 0 {
		i -= len(m.CurrentPublicKey)
		copy(dAtA[i:], m.CurrentPublicKey)
		i = encodeVarintAuthenticator(dAtA, i, uint64(len(m.CurrentPublicKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.NextNonce != 0 {
		i = encodeVarintAuthenticator(dAtA, i, uint64(m.NextNonce))
		i--
		dAtA[i] = 0x18
	}
	if m.CurrentNonce != 0 {
		i = encodeVarintAuthenticator(dAtA, i, uint64(m.CurrentNonce))
		i--
		dAtA[i] = 0x10
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthenticator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateUserPublicKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserPublicKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateUserPublicKeyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiryDate != 0 {
		i = encodeVarintAuthenticator(dAtA, i, uint64(m.ExpiryDate))
		i--
		dAtA[i] = 0x30
	}
	if len(m.UserPublicKey) > 0 {
		i -= len(m.UserPublicKey)
		copy(dAtA[i:], m.UserPublicKey)
		i = encodeVarintAuthenticator(dAtA, i, uint64(len(m.UserPublicKey)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Nonce != 0 {
		i = encodeVarintAuthenticator(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x20
	}
	if m.CurrentNonce != 0 {
		i = encodeVarintAuthenticator(dAtA, i, uint64(m.CurrentNonce))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintAuthenticator(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountId) > 0 {
		i -= len(m.AccountId)
		copy(dAtA[i:], m.AccountId)
		i = encodeVarintAuthenticator(dAtA, i, uint64(len(m.AccountId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateUserPublicKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserPublicKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateUserPublicKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthenticator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerifyOffChainSignatureRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyOffChainSignatureRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyOffChainSignatureRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RealMsgToSign) > 0 {
		i -= len(m.RealMsgToSign)
		copy(dAtA[i:], m.RealMsgToSign)
		i = encodeVarintAuthenticator(dAtA, i, uint64(len(m.RealMsgToSign)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OffChainSig) > 0 {
		i -= len(m.OffChainSig)
		copy(dAtA[i:], m.OffChainSig)
		i = encodeVarintAuthenticator(dAtA, i, uint64(len(m.OffChainSig)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintAuthenticator(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountId) > 0 {
		i -= len(m.AccountId)
		copy(dAtA[i:], m.AccountId)
		i = encodeVarintAuthenticator(dAtA, i, uint64(len(m.AccountId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerifyGNFD1EddsaSignatureRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyGNFD1EddsaSignatureRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyGNFD1EddsaSignatureRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RealMsgToSign) > 0 {
		i -= len(m.RealMsgToSign)
		copy(dAtA[i:], m.RealMsgToSign)
		i = encodeVarintAuthenticator(dAtA, i, uint64(len(m.RealMsgToSign)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OffChainSig) > 0 {
		i -= len(m.OffChainSig)
		copy(dAtA[i:], m.OffChainSig)
		i = encodeVarintAuthenticator(dAtA, i, uint64(len(m.OffChainSig)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintAuthenticator(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountId) > 0 {
		i -= len(m.AccountId)
		copy(dAtA[i:], m.AccountId)
		i = encodeVarintAuthenticator(dAtA, i, uint64(len(m.AccountId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerifyOffChainSignatureResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyOffChainSignatureResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyOffChainSignatureResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthenticator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAuthenticator(dAtA []byte, offset int, v uint64) int {
	offset -= sovAuthenticator(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GfSpAuthenticationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthType != 0 {
		n += 1 + sovAuthenticator(uint64(m.AuthType))
	}
	l = len(m.UserAccount)
	if l > 0 {
		n += 1 + l + sovAuthenticator(uint64(l))
	}
	l = len(m.BucketName)
	if l > 0 {
		n += 1 + l + sovAuthenticator(uint64(l))
	}
	l = len(m.ObjectName)
	if l > 0 {
		n += 1 + l + sovAuthenticator(uint64(l))
	}
	return n
}

func (m *GfSpAuthenticationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovAuthenticator(uint64(l))
	}
	if m.Allowed {
		n += 2
	}
	return n
}

func (m *GetAuthNonceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovAuthenticator(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovAuthenticator(uint64(l))
	}
	return n
}

func (m *GetAuthNonceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovAuthenticator(uint64(l))
	}
	if m.CurrentNonce != 0 {
		n += 1 + sovAuthenticator(uint64(m.CurrentNonce))
	}
	if m.NextNonce != 0 {
		n += 1 + sovAuthenticator(uint64(m.NextNonce))
	}
	l = len(m.CurrentPublicKey)
	if l > 0 {
		n += 1 + l + sovAuthenticator(uint64(l))
	}
	if m.ExpiryDate != 0 {
		n += 1 + sovAuthenticator(uint64(m.ExpiryDate))
	}
	return n
}

func (m *UpdateUserPublicKeyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovAuthenticator(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovAuthenticator(uint64(l))
	}
	if m.CurrentNonce != 0 {
		n += 1 + sovAuthenticator(uint64(m.CurrentNonce))
	}
	if m.Nonce != 0 {
		n += 1 + sovAuthenticator(uint64(m.Nonce))
	}
	l = len(m.UserPublicKey)
	if l > 0 {
		n += 1 + l + sovAuthenticator(uint64(l))
	}
	if m.ExpiryDate != 0 {
		n += 1 + sovAuthenticator(uint64(m.ExpiryDate))
	}
	return n
}

func (m *UpdateUserPublicKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovAuthenticator(uint64(l))
	}
	if m.Result {
		n += 2
	}
	return n
}

func (m *VerifyOffChainSignatureRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovAuthenticator(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovAuthenticator(uint64(l))
	}
	l = len(m.OffChainSig)
	if l > 0 {
		n += 1 + l + sovAuthenticator(uint64(l))
	}
	l = len(m.RealMsgToSign)
	if l > 0 {
		n += 1 + l + sovAuthenticator(uint64(l))
	}
	return n
}

func (m *VerifyGNFD1EddsaSignatureRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovAuthenticator(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovAuthenticator(uint64(l))
	}
	l = len(m.OffChainSig)
	if l > 0 {
		n += 1 + l + sovAuthenticator(uint64(l))
	}
	l = len(m.RealMsgToSign)
	if l > 0 {
		n += 1 + l + sovAuthenticator(uint64(l))
	}
	return n
}

func (m *VerifyOffChainSignatureResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovAuthenticator(uint64(l))
	}
	if m.Result {
		n += 2
	}
	return n
}

func sovAuthenticator(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAuthenticator(x uint64) (n int) {
	return sovAuthenticator(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GfSpAuthenticationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthenticator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpAuthenticationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpAuthenticationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthType", wireType)
			}
			m.AuthType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthenticator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthenticator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BucketName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthenticator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthenticator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpAuthenticationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthenticator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpAuthenticationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpAuthenticationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthenticator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &gfsperrors.GfSpError{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allowed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Allowed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuthenticator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAuthNonceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthenticator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAuthNonceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAuthNonceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthenticator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthenticator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthenticator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAuthNonceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthenticator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAuthNonceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAuthNonceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthenticator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &gfsperrors.GfSpError{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentNonce", wireType)
			}
			m.CurrentNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentNonce |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextNonce", wireType)
			}
			m.NextNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextNonce |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentPublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthenticator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentPublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryDate", wireType)
			}
			m.ExpiryDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryDate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthenticator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserPublicKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthenticator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserPublicKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserPublicKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthenticator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthenticator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentNonce", wireType)
			}
			m.CurrentNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentNonce |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthenticator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserPublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryDate", wireType)
			}
			m.ExpiryDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryDate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthenticator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserPublicKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthenticator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserPublicKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserPublicKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthenticator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &gfsperrors.GfSpError{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuthenticator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyOffChainSignatureRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthenticator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyOffChainSignatureRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyOffChainSignatureRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthenticator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthenticator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffChainSig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthenticator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OffChainSig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealMsgToSign", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthenticator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RealMsgToSign = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthenticator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyGNFD1EddsaSignatureRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthenticator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyGNFD1EddsaSignatureRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyGNFD1EddsaSignatureRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthenticator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthenticator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffChainSig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthenticator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OffChainSig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealMsgToSign", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthenticator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RealMsgToSign = append(m.RealMsgToSign[:0], dAtA[iNdEx:postIndex]...)
			if m.RealMsgToSign == nil {
				m.RealMsgToSign = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthenticator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyOffChainSignatureResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthenticator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyOffChainSignatureResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyOffChainSignatureResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthenticator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &gfsperrors.GfSpError{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuthenticator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthenticator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAuthenticator(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAuthenticator
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuthenticator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAuthenticator
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAuthenticator
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAuthenticator
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAuthenticator        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAuthenticator          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAuthenticator = fmt.Errorf("proto: unexpected end of group")
)
