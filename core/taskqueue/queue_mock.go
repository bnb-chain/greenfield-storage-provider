// Code generated by MockGen. DO NOT EDIT.
// Source: ./queue.go

// Package taskqueue is a generated GoMock package.
package taskqueue

import (
	reflect "reflect"

	rcmgr "github.com/bnb-chain/greenfield-storage-provider/core/rcmgr"
	task "github.com/bnb-chain/greenfield-storage-provider/core/task"
	gomock "go.uber.org/mock/gomock"
)

// MockTQueue is a mock of TQueue interface.
type MockTQueue struct {
	ctrl     *gomock.Controller
	recorder *MockTQueueMockRecorder
}

// MockTQueueMockRecorder is the mock recorder for MockTQueue.
type MockTQueueMockRecorder struct {
	mock *MockTQueue
}

// NewMockTQueue creates a new mock instance.
func NewMockTQueue(ctrl *gomock.Controller) *MockTQueue {
	mock := &MockTQueue{ctrl: ctrl}
	mock.recorder = &MockTQueueMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTQueue) EXPECT() *MockTQueueMockRecorder {
	return m.recorder
}

// Cap mocks base method.
func (m *MockTQueue) Cap() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Cap")
	ret0, _ := ret[0].(int)
	return ret0
}

// Cap indicates an expected call of Cap.
func (mr *MockTQueueMockRecorder) Cap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cap", reflect.TypeOf((*MockTQueue)(nil).Cap))
}

// Has mocks base method.
func (m *MockTQueue) Has(arg0 task.TKey) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Has", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Has indicates an expected call of Has.
func (mr *MockTQueueMockRecorder) Has(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Has", reflect.TypeOf((*MockTQueue)(nil).Has), arg0)
}

// Len mocks base method.
func (m *MockTQueue) Len() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Len")
	ret0, _ := ret[0].(int)
	return ret0
}

// Len indicates an expected call of Len.
func (mr *MockTQueueMockRecorder) Len() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Len", reflect.TypeOf((*MockTQueue)(nil).Len))
}

// Pop mocks base method.
func (m *MockTQueue) Pop() task.Task {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Pop")
	ret0, _ := ret[0].(task.Task)
	return ret0
}

// Pop indicates an expected call of Pop.
func (mr *MockTQueueMockRecorder) Pop() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pop", reflect.TypeOf((*MockTQueue)(nil).Pop))
}

// PopByKey mocks base method.
func (m *MockTQueue) PopByKey(arg0 task.TKey) task.Task {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PopByKey", arg0)
	ret0, _ := ret[0].(task.Task)
	return ret0
}

// PopByKey indicates an expected call of PopByKey.
func (mr *MockTQueueMockRecorder) PopByKey(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PopByKey", reflect.TypeOf((*MockTQueue)(nil).PopByKey), arg0)
}

// Push mocks base method.
func (m *MockTQueue) Push(arg0 task.Task) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Push", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Push indicates an expected call of Push.
func (mr *MockTQueueMockRecorder) Push(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Push", reflect.TypeOf((*MockTQueue)(nil).Push), arg0)
}

// ScanTask mocks base method.
func (m *MockTQueue) ScanTask(arg0 func(task.Task)) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ScanTask", arg0)
}

// ScanTask indicates an expected call of ScanTask.
func (mr *MockTQueueMockRecorder) ScanTask(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanTask", reflect.TypeOf((*MockTQueue)(nil).ScanTask), arg0)
}

// Top mocks base method.
func (m *MockTQueue) Top() task.Task {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Top")
	ret0, _ := ret[0].(task.Task)
	return ret0
}

// Top indicates an expected call of Top.
func (mr *MockTQueueMockRecorder) Top() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Top", reflect.TypeOf((*MockTQueue)(nil).Top))
}

// MockTQueueWithLimit is a mock of TQueueWithLimit interface.
type MockTQueueWithLimit struct {
	ctrl     *gomock.Controller
	recorder *MockTQueueWithLimitMockRecorder
}

// MockTQueueWithLimitMockRecorder is the mock recorder for MockTQueueWithLimit.
type MockTQueueWithLimitMockRecorder struct {
	mock *MockTQueueWithLimit
}

// NewMockTQueueWithLimit creates a new mock instance.
func NewMockTQueueWithLimit(ctrl *gomock.Controller) *MockTQueueWithLimit {
	mock := &MockTQueueWithLimit{ctrl: ctrl}
	mock.recorder = &MockTQueueWithLimitMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTQueueWithLimit) EXPECT() *MockTQueueWithLimitMockRecorder {
	return m.recorder
}

// Cap mocks base method.
func (m *MockTQueueWithLimit) Cap() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Cap")
	ret0, _ := ret[0].(int)
	return ret0
}

// Cap indicates an expected call of Cap.
func (mr *MockTQueueWithLimitMockRecorder) Cap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cap", reflect.TypeOf((*MockTQueueWithLimit)(nil).Cap))
}

// Has mocks base method.
func (m *MockTQueueWithLimit) Has(arg0 task.TKey) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Has", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Has indicates an expected call of Has.
func (mr *MockTQueueWithLimitMockRecorder) Has(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Has", reflect.TypeOf((*MockTQueueWithLimit)(nil).Has), arg0)
}

// Len mocks base method.
func (m *MockTQueueWithLimit) Len() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Len")
	ret0, _ := ret[0].(int)
	return ret0
}

// Len indicates an expected call of Len.
func (mr *MockTQueueWithLimitMockRecorder) Len() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Len", reflect.TypeOf((*MockTQueueWithLimit)(nil).Len))
}

// PopByKey mocks base method.
func (m *MockTQueueWithLimit) PopByKey(arg0 task.TKey) task.Task {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PopByKey", arg0)
	ret0, _ := ret[0].(task.Task)
	return ret0
}

// PopByKey indicates an expected call of PopByKey.
func (mr *MockTQueueWithLimitMockRecorder) PopByKey(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PopByKey", reflect.TypeOf((*MockTQueueWithLimit)(nil).PopByKey), arg0)
}

// PopByLimit mocks base method.
func (m *MockTQueueWithLimit) PopByLimit(arg0 rcmgr.Limit) task.Task {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PopByLimit", arg0)
	ret0, _ := ret[0].(task.Task)
	return ret0
}

// PopByLimit indicates an expected call of PopByLimit.
func (mr *MockTQueueWithLimitMockRecorder) PopByLimit(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PopByLimit", reflect.TypeOf((*MockTQueueWithLimit)(nil).PopByLimit), arg0)
}

// Push mocks base method.
func (m *MockTQueueWithLimit) Push(arg0 task.Task) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Push", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Push indicates an expected call of Push.
func (mr *MockTQueueWithLimitMockRecorder) Push(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Push", reflect.TypeOf((*MockTQueueWithLimit)(nil).Push), arg0)
}

// ScanTask mocks base method.
func (m *MockTQueueWithLimit) ScanTask(arg0 func(task.Task)) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ScanTask", arg0)
}

// ScanTask indicates an expected call of ScanTask.
func (mr *MockTQueueWithLimitMockRecorder) ScanTask(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanTask", reflect.TypeOf((*MockTQueueWithLimit)(nil).ScanTask), arg0)
}

// TopByLimit mocks base method.
func (m *MockTQueueWithLimit) TopByLimit(arg0 rcmgr.Limit) task.Task {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TopByLimit", arg0)
	ret0, _ := ret[0].(task.Task)
	return ret0
}

// TopByLimit indicates an expected call of TopByLimit.
func (mr *MockTQueueWithLimitMockRecorder) TopByLimit(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TopByLimit", reflect.TypeOf((*MockTQueueWithLimit)(nil).TopByLimit), arg0)
}

// MockTQueueOnStrategy is a mock of TQueueOnStrategy interface.
type MockTQueueOnStrategy struct {
	ctrl     *gomock.Controller
	recorder *MockTQueueOnStrategyMockRecorder
}

// MockTQueueOnStrategyMockRecorder is the mock recorder for MockTQueueOnStrategy.
type MockTQueueOnStrategyMockRecorder struct {
	mock *MockTQueueOnStrategy
}

// NewMockTQueueOnStrategy creates a new mock instance.
func NewMockTQueueOnStrategy(ctrl *gomock.Controller) *MockTQueueOnStrategy {
	mock := &MockTQueueOnStrategy{ctrl: ctrl}
	mock.recorder = &MockTQueueOnStrategyMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTQueueOnStrategy) EXPECT() *MockTQueueOnStrategyMockRecorder {
	return m.recorder
}

// Cap mocks base method.
func (m *MockTQueueOnStrategy) Cap() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Cap")
	ret0, _ := ret[0].(int)
	return ret0
}

// Cap indicates an expected call of Cap.
func (mr *MockTQueueOnStrategyMockRecorder) Cap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cap", reflect.TypeOf((*MockTQueueOnStrategy)(nil).Cap))
}

// Has mocks base method.
func (m *MockTQueueOnStrategy) Has(arg0 task.TKey) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Has", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Has indicates an expected call of Has.
func (mr *MockTQueueOnStrategyMockRecorder) Has(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Has", reflect.TypeOf((*MockTQueueOnStrategy)(nil).Has), arg0)
}

// Len mocks base method.
func (m *MockTQueueOnStrategy) Len() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Len")
	ret0, _ := ret[0].(int)
	return ret0
}

// Len indicates an expected call of Len.
func (mr *MockTQueueOnStrategyMockRecorder) Len() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Len", reflect.TypeOf((*MockTQueueOnStrategy)(nil).Len))
}

// Pop mocks base method.
func (m *MockTQueueOnStrategy) Pop() task.Task {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Pop")
	ret0, _ := ret[0].(task.Task)
	return ret0
}

// Pop indicates an expected call of Pop.
func (mr *MockTQueueOnStrategyMockRecorder) Pop() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pop", reflect.TypeOf((*MockTQueueOnStrategy)(nil).Pop))
}

// PopByKey mocks base method.
func (m *MockTQueueOnStrategy) PopByKey(arg0 task.TKey) task.Task {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PopByKey", arg0)
	ret0, _ := ret[0].(task.Task)
	return ret0
}

// PopByKey indicates an expected call of PopByKey.
func (mr *MockTQueueOnStrategyMockRecorder) PopByKey(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PopByKey", reflect.TypeOf((*MockTQueueOnStrategy)(nil).PopByKey), arg0)
}

// Push mocks base method.
func (m *MockTQueueOnStrategy) Push(arg0 task.Task) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Push", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Push indicates an expected call of Push.
func (mr *MockTQueueOnStrategyMockRecorder) Push(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Push", reflect.TypeOf((*MockTQueueOnStrategy)(nil).Push), arg0)
}

// ScanTask mocks base method.
func (m *MockTQueueOnStrategy) ScanTask(arg0 func(task.Task)) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ScanTask", arg0)
}

// ScanTask indicates an expected call of ScanTask.
func (mr *MockTQueueOnStrategyMockRecorder) ScanTask(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanTask", reflect.TypeOf((*MockTQueueOnStrategy)(nil).ScanTask), arg0)
}

// SetFilterTaskStrategy mocks base method.
func (m *MockTQueueOnStrategy) SetFilterTaskStrategy(arg0 func(task.Task) bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetFilterTaskStrategy", arg0)
}

// SetFilterTaskStrategy indicates an expected call of SetFilterTaskStrategy.
func (mr *MockTQueueOnStrategyMockRecorder) SetFilterTaskStrategy(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetFilterTaskStrategy", reflect.TypeOf((*MockTQueueOnStrategy)(nil).SetFilterTaskStrategy), arg0)
}

// SetRetireTaskStrategy mocks base method.
func (m *MockTQueueOnStrategy) SetRetireTaskStrategy(arg0 func(task.Task) bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetRetireTaskStrategy", arg0)
}

// SetRetireTaskStrategy indicates an expected call of SetRetireTaskStrategy.
func (mr *MockTQueueOnStrategyMockRecorder) SetRetireTaskStrategy(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetRetireTaskStrategy", reflect.TypeOf((*MockTQueueOnStrategy)(nil).SetRetireTaskStrategy), arg0)
}

// Top mocks base method.
func (m *MockTQueueOnStrategy) Top() task.Task {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Top")
	ret0, _ := ret[0].(task.Task)
	return ret0
}

// Top indicates an expected call of Top.
func (mr *MockTQueueOnStrategyMockRecorder) Top() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Top", reflect.TypeOf((*MockTQueueOnStrategy)(nil).Top))
}

// MockTQueueOnStrategyWithLimit is a mock of TQueueOnStrategyWithLimit interface.
type MockTQueueOnStrategyWithLimit struct {
	ctrl     *gomock.Controller
	recorder *MockTQueueOnStrategyWithLimitMockRecorder
}

// MockTQueueOnStrategyWithLimitMockRecorder is the mock recorder for MockTQueueOnStrategyWithLimit.
type MockTQueueOnStrategyWithLimitMockRecorder struct {
	mock *MockTQueueOnStrategyWithLimit
}

// NewMockTQueueOnStrategyWithLimit creates a new mock instance.
func NewMockTQueueOnStrategyWithLimit(ctrl *gomock.Controller) *MockTQueueOnStrategyWithLimit {
	mock := &MockTQueueOnStrategyWithLimit{ctrl: ctrl}
	mock.recorder = &MockTQueueOnStrategyWithLimitMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTQueueOnStrategyWithLimit) EXPECT() *MockTQueueOnStrategyWithLimitMockRecorder {
	return m.recorder
}

// Cap mocks base method.
func (m *MockTQueueOnStrategyWithLimit) Cap() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Cap")
	ret0, _ := ret[0].(int)
	return ret0
}

// Cap indicates an expected call of Cap.
func (mr *MockTQueueOnStrategyWithLimitMockRecorder) Cap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cap", reflect.TypeOf((*MockTQueueOnStrategyWithLimit)(nil).Cap))
}

// Has mocks base method.
func (m *MockTQueueOnStrategyWithLimit) Has(arg0 task.TKey) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Has", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Has indicates an expected call of Has.
func (mr *MockTQueueOnStrategyWithLimitMockRecorder) Has(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Has", reflect.TypeOf((*MockTQueueOnStrategyWithLimit)(nil).Has), arg0)
}

// Len mocks base method.
func (m *MockTQueueOnStrategyWithLimit) Len() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Len")
	ret0, _ := ret[0].(int)
	return ret0
}

// Len indicates an expected call of Len.
func (mr *MockTQueueOnStrategyWithLimitMockRecorder) Len() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Len", reflect.TypeOf((*MockTQueueOnStrategyWithLimit)(nil).Len))
}

// PopByKey mocks base method.
func (m *MockTQueueOnStrategyWithLimit) PopByKey(arg0 task.TKey) task.Task {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PopByKey", arg0)
	ret0, _ := ret[0].(task.Task)
	return ret0
}

// PopByKey indicates an expected call of PopByKey.
func (mr *MockTQueueOnStrategyWithLimitMockRecorder) PopByKey(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PopByKey", reflect.TypeOf((*MockTQueueOnStrategyWithLimit)(nil).PopByKey), arg0)
}

// PopByLimit mocks base method.
func (m *MockTQueueOnStrategyWithLimit) PopByLimit(arg0 rcmgr.Limit) task.Task {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PopByLimit", arg0)
	ret0, _ := ret[0].(task.Task)
	return ret0
}

// PopByLimit indicates an expected call of PopByLimit.
func (mr *MockTQueueOnStrategyWithLimitMockRecorder) PopByLimit(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PopByLimit", reflect.TypeOf((*MockTQueueOnStrategyWithLimit)(nil).PopByLimit), arg0)
}

// Push mocks base method.
func (m *MockTQueueOnStrategyWithLimit) Push(arg0 task.Task) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Push", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Push indicates an expected call of Push.
func (mr *MockTQueueOnStrategyWithLimitMockRecorder) Push(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Push", reflect.TypeOf((*MockTQueueOnStrategyWithLimit)(nil).Push), arg0)
}

// ScanTask mocks base method.
func (m *MockTQueueOnStrategyWithLimit) ScanTask(arg0 func(task.Task)) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ScanTask", arg0)
}

// ScanTask indicates an expected call of ScanTask.
func (mr *MockTQueueOnStrategyWithLimitMockRecorder) ScanTask(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanTask", reflect.TypeOf((*MockTQueueOnStrategyWithLimit)(nil).ScanTask), arg0)
}

// SetFilterTaskStrategy mocks base method.
func (m *MockTQueueOnStrategyWithLimit) SetFilterTaskStrategy(arg0 func(task.Task) bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetFilterTaskStrategy", arg0)
}

// SetFilterTaskStrategy indicates an expected call of SetFilterTaskStrategy.
func (mr *MockTQueueOnStrategyWithLimitMockRecorder) SetFilterTaskStrategy(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetFilterTaskStrategy", reflect.TypeOf((*MockTQueueOnStrategyWithLimit)(nil).SetFilterTaskStrategy), arg0)
}

// SetRetireTaskStrategy mocks base method.
func (m *MockTQueueOnStrategyWithLimit) SetRetireTaskStrategy(arg0 func(task.Task) bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetRetireTaskStrategy", arg0)
}

// SetRetireTaskStrategy indicates an expected call of SetRetireTaskStrategy.
func (mr *MockTQueueOnStrategyWithLimitMockRecorder) SetRetireTaskStrategy(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetRetireTaskStrategy", reflect.TypeOf((*MockTQueueOnStrategyWithLimit)(nil).SetRetireTaskStrategy), arg0)
}

// TopByLimit mocks base method.
func (m *MockTQueueOnStrategyWithLimit) TopByLimit(arg0 rcmgr.Limit) task.Task {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TopByLimit", arg0)
	ret0, _ := ret[0].(task.Task)
	return ret0
}

// TopByLimit indicates an expected call of TopByLimit.
func (mr *MockTQueueOnStrategyWithLimitMockRecorder) TopByLimit(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TopByLimit", reflect.TypeOf((*MockTQueueOnStrategyWithLimit)(nil).TopByLimit), arg0)
}

// MockTQueueStrategy is a mock of TQueueStrategy interface.
type MockTQueueStrategy struct {
	ctrl     *gomock.Controller
	recorder *MockTQueueStrategyMockRecorder
}

// MockTQueueStrategyMockRecorder is the mock recorder for MockTQueueStrategy.
type MockTQueueStrategyMockRecorder struct {
	mock *MockTQueueStrategy
}

// NewMockTQueueStrategy creates a new mock instance.
func NewMockTQueueStrategy(ctrl *gomock.Controller) *MockTQueueStrategy {
	mock := &MockTQueueStrategy{ctrl: ctrl}
	mock.recorder = &MockTQueueStrategyMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTQueueStrategy) EXPECT() *MockTQueueStrategyMockRecorder {
	return m.recorder
}

// SetFilterTaskStrategy mocks base method.
func (m *MockTQueueStrategy) SetFilterTaskStrategy(arg0 func(task.Task) bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetFilterTaskStrategy", arg0)
}

// SetFilterTaskStrategy indicates an expected call of SetFilterTaskStrategy.
func (mr *MockTQueueStrategyMockRecorder) SetFilterTaskStrategy(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetFilterTaskStrategy", reflect.TypeOf((*MockTQueueStrategy)(nil).SetFilterTaskStrategy), arg0)
}

// SetRetireTaskStrategy mocks base method.
func (m *MockTQueueStrategy) SetRetireTaskStrategy(arg0 func(task.Task) bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetRetireTaskStrategy", arg0)
}

// SetRetireTaskStrategy indicates an expected call of SetRetireTaskStrategy.
func (mr *MockTQueueStrategyMockRecorder) SetRetireTaskStrategy(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetRetireTaskStrategy", reflect.TypeOf((*MockTQueueStrategy)(nil).SetRetireTaskStrategy), arg0)
}
